---
title: "CSS Specificity and Priority"
description: "Understanding how CSS determines which rules to apply when multiple selectors target the same element"
---

## What is CSS Specificity?

When multiple CSS rules target the same element and try to style the same property, the browser needs to decide which rule to apply. **Specificity** is the system CSS uses to determine which rule "wins" when there are conflicts.

**Key Concept:**
The more specific a selector is, the higher its priority. More specific rules override less specific ones.

---

## The CSS Priority Ranking System

CSS uses a priority ranking system from 0 (lowest) to 5 (highest) to determine which rules are applied:

| Priority | Type                         | Example                                               |
| -------- | ---------------------------- | ----------------------------------------------------- |
| **5**    | `!important`                 | `color: red !important;`                              |
| **4**    | Inline styles                | `<p style="color: red;">`                             |
| **3**    | ID selectors                 | `#header { color: red; }`                             |
| **2**    | Class/Pseudo-class selectors | `.intro { color: red; }` or `a:hover { color: red; }` |
| **1**    | Element selectors            | `p { color: red; }`                                   |
| **0**    | Universal selector           | `* { color: red; }`                                   |

---

## Priority Level 5: `!important`

The `!important` keyword overrides all other declarations, regardless of specificity.

**Syntax:**

```css
selector {
  property: value !important;
}
```

**Example:**

```css
p {
  color: blue !important;
}

#special-paragraph {
  color: red; /* This will NOT apply */
}
```

```html
<p id="special-paragraph">This text will be blue, not red!</p>
```

**Why `!important` is Discouraged:**

- Makes debugging difficult
- Breaks the natural cascade of CSS
- Creates specificity wars (needing more `!important` to override `!important`)
- Makes code harder to maintain

**When `!important` Might Be Acceptable:**

- Overriding third-party library styles you can't modify
- Creating utility classes that should always apply (e.g., `.hidden { display: none !important; }`)
- Quick fixes during development (but should be refactored later)

---

## Priority Level 4: Inline Styles

Inline styles are CSS rules written directly in the HTML element's `style` attribute.

**Example:**

```html
<p style="color: red; font-size: 20px;">This paragraph has inline styles</p>
```

**Why Inline Styles are Discouraged:**

- Mixes HTML structure with styling (violates separation of concerns)
- Can't be reused across multiple elements
- Hard to maintain and update
- Can't use pseudo-classes (`:hover`, `:focus`, etc.)
- Difficult to override without `!important`

**When Inline Styles Might Be Acceptable:**

- Dynamic styles generated by JavaScript
- Email templates (many email clients require inline styles)
- Quick prototyping or testing

**Best Practice:**
Use classes instead:

```html
<!-- Bad -->
<p style="color: red; font-size: 20px;">Text</p>

<!-- Good -->
<p class="highlight">Text</p>
```

```css
.highlight {
  color: red;
  font-size: 20px;
}
```

---

## Priority Level 3: ID Selectors

ID selectors target elements with a specific `id` attribute.

**Example:**

```css
#header {
  background-color: blue;
}
```

```html
<header id="header">My Website</header>
```

**Key Points:**

- Very high specificity (only below inline styles and `!important`)
- Can override class and element selectors
- IDs should be unique on a page

**Example of ID Priority:**

```css
/* Priority 3 - ID selector */
#intro {
  color: blue;
}

/* Priority 2 - Class selector */
.text {
  color: red;
}

/* Priority 1 - Element selector */
p {
  color: green;
}
```

```html
<p id="intro" class="text">This text will be blue</p>
<!-- ID wins over class and element selectors -->
```

---

## Priority Level 2: Class and Pseudo-Class Selectors

This category includes:

- Class selectors (`.classname`)
- Attribute selectors (`[type="text"]`)
- Pseudo-classes (`:hover`, `:first-child`, etc.)

**Examples:**

```css
/* Class selector */
.highlight {
  color: orange;
}

/* Attribute selector */
input[type="text"] {
  border: 1px solid gray;
}

/* Pseudo-class selector */
a:hover {
  color: red;
}
```

**Class Selectors Override Element Selectors:**

```css
/* Priority 2 - Class */
.important {
  color: red;
}

/* Priority 1 - Element */
p {
  color: blue;
}
```

```html
<p class="important">This text will be red</p>
<!-- Class wins over element selector -->
```

---

## Priority Level 1: Element Selectors

Element selectors (also called type selectors) target HTML elements by their tag name.

**Examples:**

```css
p {
  color: black;
}

h1 {
  font-size: 32px;
}

div {
  margin: 10px;
}
```

**Element Selectors are Overridden by Classes:**

```css
/* Priority 1 - Element */
p {
  color: blue;
}

/* Priority 2 - Class */
.special {
  color: red;
}
```

```html
<p class="special">This text will be red</p>
```

---

## Priority Level 0: Universal Selector

The universal selector (`*`) targets all elements and has the lowest specificity.

**Example:**

```css
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}
```

**Key Points:**

- Lowest priority - overridden by everything else
- Commonly used for CSS resets
- Useful for applying base styles to all elements

---

## Calculating Specificity for Combined Selectors

When you combine multiple selectors, their specificity values add up.

**Specificity Calculation Format: (ID, CLASS, ELEMENT)**

Think of it like counting in three columns:

- Column 1: Number of ID selectors
- Column 2: Number of class/pseudo-class/attribute selectors
- Column 3: Number of element selectors

**Examples:**

```css
/* (0, 0, 1) - One element selector */
p {
  color: blue;
}

/* (0, 1, 0) - One class selector */
.intro {
  color: red;
}

/* (0, 1, 1) - One class + one element */
p.intro {
  color: green;
}

/* (1, 0, 0) - One ID selector */
#header {
  color: purple;
}

/* (1, 1, 1) - One ID + one class + one element */
div#header.main {
  color: orange;
}

/* (0, 2, 1) - Two classes + one element */
p.intro.highlight {
  color: yellow;
}
```

**Comparison:**

- `(1, 0, 0)` beats `(0, 10, 10)` - One ID is more specific than any number of classes or elements
- `(0, 2, 0)` beats `(0, 1, 5)` - Two classes beat one class + five elements
- `(0, 1, 1)` beats `(0, 1, 0)` - When classes are equal, elements are the tiebreaker

---

## The Cascade: When Specificity is Equal

When two rules have the **same specificity**, the one that appears **last** in the CSS file wins.

**Example:**

```css
.text {
  color: blue;
}

.text {
  color: red; /* This wins because it comes last */
}
```

```html
<p class="text">This text will be red</p>
```

**This applies to multiple stylesheets too:**

```html
<head>
  <link rel="stylesheet" href="style1.css" />
  <link rel="stylesheet" href="style2.css" />
  <!-- Rules from style2.css will override style1.css if they have equal specificity -->
</head>
```

---

## VSCode Specificity Helper

VSCode provides a helpful feature to check selector specificity:

**How to Use:**

1. Hover your mouse over any CSS selector in your stylesheet
2. A tooltip will appear showing "Selector Specificity"
3. The specificity is displayed in the format `(ID, CLASS, ELEMENT)`

**Example:**

```css
div#header.main p.intro {
  color: blue;
}
/* Hovering shows: Selector Specificity: (1, 2, 2) */
```

This means:

- 1 ID selector (`#header`)
- 2 class selectors (`.main`, `.intro`)
- 2 element selectors (`div`, `p`)

---

## Practical Examples

### Example 1: Understanding Priority

```css
/* Priority 1: Element selector */
p {
  color: black;
  font-size: 16px;
}

/* Priority 2: Class selector (wins for color) */
.highlight {
  color: red;
}

/* Priority 3: ID selector (wins for everything) */
#special {
  color: blue;
  font-size: 20px;
}
```

```html
<p>Normal paragraph - black text, 16px</p>
<p class="highlight">Highlighted paragraph - red text, 16px</p>
<p id="special" class="highlight">Special paragraph - blue text, 20px</p>
```

### Example 2: Combining Selectors

```css
/* Specificity: (0, 0, 1) */
p {
  color: blue;
}

/* Specificity: (0, 1, 1) - This wins */
p.intro {
  color: red;
}
```

```html
<p class="intro">This text will be red</p>
<!-- p.intro is more specific than just p -->
```

### Example 3: Cascade with Equal Specificity

```css
/* Both have specificity (0, 1, 0) */
.button {
  background-color: blue;
  color: white;
}

.button {
  background-color: green; /* This wins for background-color */
}
```

```html
<button class="button">Button will be green with white text</button>
```

### Example 4: The !important Override

```css
/* Specificity: (1, 0, 0) - ID selector */
#header {
  color: blue;
}

/* Specificity: (0, 0, 1) - But !important makes it win */
p {
  color: red !important;
}
```

```html
<p id="header">This text will be red because of !important</p>
```

---

## Common Pitfalls and Solutions

### Pitfall 1: Over-Specific Selectors

**Problem:**

```css
div#container ul.nav li.item a.link {
  color: blue;
}
/* Specificity: (1, 3, 4) - Very hard to override! */
```

**Solution:**
Use simpler, more maintainable selectors:

```css
.nav-link {
  color: blue;
}
/* Specificity: (0, 1, 0) - Easy to work with */
```

### Pitfall 2: Inline Style Wars

**Problem:**

```html
<p style="color: red;">Text</p>
```

```css
p {
  color: blue !important; /* Need !important to override inline style */
}
```

**Solution:**
Avoid inline styles and use classes:

```html
<p class="text">Text</p>
```

```css
.text {
  color: blue;
}
```

### Pitfall 3: ID Overuse

**Problem:**

```css
#header {
  color: blue;
}
#header {
  font-size: 20px;
} /* Multiple rules for same ID */
#main-header {
  color: red;
} /* Need even more specific ID to override */
```

**Solution:**
Use classes for styling, reserve IDs for JavaScript or unique page landmarks:

```css
.header {
  color: blue;
}
.header-large {
  font-size: 20px;
}
```

---

## Best Practices

1. **Keep Specificity Low**

   - Use classes for most styling
   - Avoid overly complex selectors
   - Easier to override when needed

2. **Avoid `!important`**

   - Only use when absolutely necessary
   - Consider refactoring instead
   - Document why it's needed if you must use it

3. **Avoid Inline Styles**

   - Keep HTML and CSS separated
   - Use classes instead
   - Exception: Dynamically generated styles via JavaScript

4. **Use IDs Sparingly for Styling**

   - Reserve IDs for JavaScript or page landmarks
   - Use classes for reusable styles
   - IDs make styles hard to override

5. **Organize CSS by Specificity**

   - Put general styles first
   - Put specific styles later
   - Makes the cascade work in your favor

6. **Use VSCode's Specificity Helper**
   - Check specificity when debugging
   - Understand why styles aren't applying
   - Learn to write better selectors

---

## Summary

**Priority Hierarchy (High to Low):**

1. `!important` (avoid)
2. Inline styles (avoid)
3. ID selectors (use sparingly)
4. Class/Pseudo-class selectors (preferred for most styling)
5. Element selectors (good for base styles)
6. Universal selector (lowest priority)

**Key Takeaways:**

- More specific selectors override less specific ones
- When specificity is equal, the last rule wins (cascade)
- Keep specificity low for maintainable CSS
- Avoid `!important` and inline styles in production
- Use classes for most styling needs
- Leverage VSCode's specificity helper for debugging

**Remember:** The goal is to write CSS that is easy to understand, maintain, and override when needed. Lower specificity is usually better!
